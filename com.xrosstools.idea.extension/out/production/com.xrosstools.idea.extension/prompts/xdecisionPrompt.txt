# xdecision生成规范
xdecision是决策树模型，一个模型只包含一个决策树

## XML格式规范
- 开头固定：`<?xml version="1.0" encoding="UTF-8"?>`：必须完整输出
- `<decision_tree alignment="0.5" layout="0">`：根节点（父节点，内部包含'<comments>'节点，`<parser>`节点，`<evaluator>`节点，`<user_defined_types>`节点，`<user_defined_enums>`节点，`<constants>`节点，`<factors>`节点，`<nodes>`节点，`<decisions>`节点)
  - `<comments>模型描述<comments/>`：模型描述（字符串，必填），概括用户需求的核心思想
  - `<parser>Java类全名，缺省为`com.xrosstools.xdecision.ext.XrossEvaluator`</parser>`：表达式解析器
  - `<evaluator>Java类全名，缺省为`com.xrosstools.xdecision.ext.XrossEvaluator`</evaluator>`：表达式求值器
  - `<user_defined_types/>`：目前用不到，请原样输出
  - `<user_defined_enums/>`：目前用不到，请原样输出
  - `<factors>`：决策因素列表
    - `<factor id="决策因素标识符，例如`Age`" index="决策因素的索引值，从0开始" type="决策因素的数据类型，例如String"/>`：决策因素，由用户提供的用于对决策路径进行判断选择的变量
      - 决策因素标识符必须为英文，符合Java标识符规范，如果在用户原文中使用中文，必须翻译为英文
      - 决策因素标识符在决策因素列表中必须唯一
      - `type`属性可选范围为
        - `String`：字符串类型
        - `Number`：所有数字类型，包括整型和浮点
        - `Boolean`：对应`true`和`false`
        - `Date`:日期类型，例如`Mon Dec 15 15:49:48 CST 2025`
        - `Array`：数组类型
        - `Collection`：对应Java Collection接口
        - `List`：对应Java Collection接口
        - `Set`：对应Java Set接口
        - `Map`：对应Java Map接口
  - `<nodes>`：决策树节点列表
    - `<node expression="表达式，例如`Age`" index="节点索引，从0开始">`：决策树节点
      - `<path expression="表达式，例如'below 20'" node_index="目标节点索引，例如1" operator="操作符，例如`==`" />`：决策路径，由当前节点指向后继节点
        - 节点可以有多个路径，如果路径条件满足，则转到指定节点；否则，如果节点有decision_index，则决策为该索引
        - `operator`属性可选值为：
          - 单值判断：
            - `IS NULL`：是否为空值
            - `IS NOT NULL`：是否不为空值
            - `IS TRUE`：是否为真
            - `IS FALSE`：是否为假
            - 注意单值判断时，`expression`属性为空，例如`<path expression="" node_index="1" operator="IS TRUE"/>``
          - 两值比较：
            - `==`：等于
            - `<>`：不等于
            - `>`：等于
            - `>=`：等于
            - `<`：等于
            - `<=`：等于
            - 生成XML时，需要对两值比较符合中包含的`<`和`>`符号进行转义
        - 字符串判断
          - `STARTS WITH`：字符串是否以什么开始
          - `NOT STARTS WITH`：字符串是否以不以什么开始
          - `ENDS WITH`：字符串是否以什么结束
          - `NOT ENDS WITH`：字符串是否不以什么结束
          - `CONTAINS`：字符串是否包含什么
          - `NOT CONTAINS`：字符串是否不包含什么
          - `MATCHES`：字符串是否符合什么模式
          - `NOT MATCHES`：字符串是否不符合什么模式
        - 集合判断
          - `BETWEEN`：等于
          - `NOT BETWEEN`：等于
          - `IN`：等于
          - `NOT IN`：等于
  - `<decisions>`：决策列表
    - `<decision id="决策标识符，例如`decision0`" index="决策索引，从0开始"/>`：决策
      - 决策标识符在决策列表中必须唯一
  - `<constants>`：用户自定义常量列表
    - `<constant id="用户自定义常量标识符，例如`Above20`" type="常量数据类型，例如`String`" value="常量值，例如`above 20`"/>`：用户自定义常量
      - `type`属性可选范围为
        - `String`：字符串类型
        - `Number`：所有数字类型，包括整型和浮点
        - `Boolean`：对应`true`和`false`
        - `Date`:日期类型，例如`Mon Dec 15 15:49:48 CST 2025`

## XML格式限制
- 格式要求
  - 表达式中的字符串值应该用``进行标志，以和其他类型区分，例如字符串值"abc"必须表示为`abc`
  - 表达式中的数值类型和对决策因素的引用直接输出，无需特殊标记

## 模型生成过程和规则：
* 提取信息：模型名，决策因素，决策，表达式等信息。
* 决策因素标识符必须为英文，符合Java标识符规范
* 决策因素的类型仅作为参考，不影响实际运行时的求值，如果用户没有指定或者无法从表达式中推导，缺省可为`String`
      - 除非用户明确要求，否则不用生成常量
* 提取节点和路径：
  * 表达式可以作为决策树节点，对表达式的判断可以作为该节点的出边，例如判断A变量，如果A大于10，那么判断B，如果A小于等于10，则判断C，这里A，B和C可以作为节点，`小于10`和`小于等于10`可作为A节点的路径，分别连接B和C表达式对应的节点
  * 节点规则
    * 中间节点必须包含表达式，也可以在用户指定的情况下包含决策，代表没有任何满足条件的路径
    * 叶子节点必须包含decision_index代表决策节点，没必要包含表达式
* 除非用户明确要求，否则严格按照用户给出的判断条件进行生成，忽略没有覆盖到的条件，无需增加默认决策

## 示例
### 示例1：字符串检验决策树
创建一个字符串检验的决策树。包含三个字符串类型的变量：A，B，C。
包含如下决策：`decision0`, `STARTS WITH`，`NOT STARTS WITH`，`ENDS WITH`，`NOT ENDS WITH`，`CONTAINS`，`NOT CONTAINS`，`MATCHES`，`NOT MATCHES`
决策过程：
- 判断A
  - 如果以"abc"开始
    - 判断B
      - 如果B不存在，决策结果为`STARTS WITH`
      - 如果B以"def"结尾
        - 决策结果为`ENDS WITH`
      - 如果B不以"def"结尾
        - 判断C
          - 如果C不存在，决策结果为`NOT ENDS WITH`
          - 如果C匹配"a*"，决策结果为`MATCHES`
  - 如果不以"abc"开始
    - 判断B
      - 如果B不存在，决策结果为`NOT STARTS WITH`
      - 如果B包含"def"
        - 判断C
          - 如果C不存在，决策结果为`CONTAINS`
          - 如果C匹配"a*"，决策结果为`MATCHES`
        - 决策结果为`ENDS WITH`
      - 如果B不以"def"结尾

### 示例1：输出XML
```xml
<?xml version="1.0" encoding="UTF-8"?>

<decision_tree alignment="0.5" layout="0">
 <comments/>
 <parser>com.xrosstools.xdecision.ext.XrossEvaluator</parser>
 <evaluator>com.xrosstools.xdecision.ext.XrossEvaluator</evaluator>
 <user_defined_types/>
 <user_defined_enums/>
 <factors>
  <factor id="A" index="0" type="String"/>
  <factor id="B" index="1" type="String"/>
  <factor id="C" index="2" type="String"/>
 </factors>
 <nodes>
  <node expression="A" index="0">
   <path expression="'abc'" node_index="1" operator="STARTS WITH"/>
   <path expression="'abc'" node_index="2" operator="NOT STARTS WITH"/>
  </node>
  <node decision_index="1" expression="B" index="1">
   <path expression="'def'" node_index="3" operator="ENDS WITH"/>
   <path expression="'def'" node_index="4" operator="NOT ENDS WITH"/>
  </node>
  <node decision_index="2" expression="B" index="2">
   <path expression="'def'" node_index="5" operator="CONTAINS"/>
   <path expression="'def'" node_index="6" operator="NOT CONTAINS"/>
  </node>
  <node decision_index="3" expression="" index="3"/>
  <node decision_index="4" expression="C" index="4">
   <path expression="'a*'" node_index="7" operator="MATCHES"/>
  </node>
  <node decision_index="5" expression="C" index="5">
   <path expression="'a*'" node_index="8" operator="NOT MATCHES"/>
  </node>
  <node decision_index="6" expression="" index="6"/>
  <node decision_index="7" expression="" index="7"/>
  <node decision_index="8" expression="" index="8"/>
 </nodes>
 <decisions>
  <decision id="decision0" index="0"/>
  <decision id="STARTS WITH" index="1"/>
  <decision id="NOT STARTS WITH" index="2"/>
  <decision id="ENDS WITH" index="3"/>
  <decision id="NOT ENDS WITH" index="4"/>
  <decision id="CONTAINS" index="5"/>
  <decision id="NOT CONTAINS" index="6"/>
  <decision id="MATCHES" index="7"/>
  <decision id="NOT MATCHES" index="8"/>
 </decisions>
 <constants/>
</decision_tree>
```

### 示例2：对象检验决策树
创建一个对象检验的决策树。包含两个变量：A，B。
包含如下决策：`decision0`, `IS TRUE`，`IS FALSE`，`IS NULL`，`IS NOT NULL`，`decision5`，`decision6`。`decision0`，`decision5`，`decision6`目前不会用到，为后继做预留
决策过程：
- 判断A
  - 如果为true
    - 判断B
      - 如果B不存在，决策结果为`IS TRUE`
      - 如果为空，返回`IS NULL`
- 如果为false
    - 判断B
      - 如果B不存在，决策结果为`IS FALSE`
      - 如果B包含"def"
      - 如果不为空，返回`IS NOT NULL`

### 示例2：输出XML
```
<?xml version="1.0" encoding="UTF-8"?>

<decision_tree alignment="0.5" layout="0">
 <comments/>
 <parser>com.xrosstools.xdecision.ext.XrossEvaluator</parser>
 <evaluator>com.xrosstools.xdecision.ext.XrossEvaluator</evaluator>
 <user_defined_types/>
 <user_defined_enums/>
 <factors>
  <factor id="A" index="0" type="String"/>
  <factor id="B" index="1" type="String"/>
 </factors>
 <nodes>
  <node expression="A" index="0">
   <path expression="" node_index="1" operator="IS TRUE"/>
   <path expression="" node_index="2" operator="IS FALSE"/>
  </node>
  <node decision_index="1" expression="B" index="1">
   <path expression="" node_index="3" operator="IS NULL"/>
  </node>
  <node decision_index="2" expression="B" index="2">
   <path expression="" node_index="4" operator="IS NOT NULL"/>
  </node>
  <node decision_index="3" expression="" index="3"/>
  <node decision_index="4" expression="" index="4"/>
 </nodes>
 <decisions>
  <decision id="decision0" index="0"/>
  <decision id="IS TRUE" index="1"/>
  <decision id="IS FALSE" index="2"/>
  <decision id="IS NULL" index="3"/>
  <decision id="IS NOT NULL" index="4"/>
  <decision id="decision5" index="5"/>
  <decision id="decision6" index="6"/>
 </decisions>
 <constants/>
</decision_tree>
```

### 示例3：集合检测决策树
创建一个对象检验的决策树。包含字符串型决策因素A，B和C，数值型变量E，F和G。
包含如下决策：`decision0`, `BETWEEN`，`NOT BETWEEN`，`IN`，`NOT IN`。
决策过程：
- 判断A
  - 如果在1和10之间
    - 判断B
      - 如果B不存在，决策结果为`BETWEEN`
      - 如果等于1，2，3，4中任意一个，返回`IN`
  - 如果不在B和C之间
    - 判断C
      - 如果不是E，F，G中任意一个，决策结果为`NOT IN`

### 示例3：输出XML
```
<?xml version="1.0" encoding="UTF-8"?>

<decision_tree alignment="0.5" layout="0">
 <comments/>
 <parser>com.xrosstools.xdecision.ext.XrossEvaluator</parser>
 <evaluator>com.xrosstools.xdecision.ext.XrossEvaluator</evaluator>
 <user_defined_types/>
 <user_defined_enums/>
 <factors>
  <factor id="A" index="0" type="String"/>
  <factor id="B" index="1" type="String"/>
  <factor id="C" index="2" type="String"/>
  <factor id="E" index="3" type="Number"/>
  <factor id="F" index="4" type="Number"/>
  <factor id="G" index="5" type="Number"/>
 </factors>
 <nodes>
  <node expression="A" index="0">
   <path expression="1,10" node_index="1" operator="BETWEEN"/>
   <path expression="B,C" node_index="2" operator="NOT BETWEEN"/>
  </node>
  <node decision_index="1" expression="B" index="1">
   <path expression="1,2,3,4" node_index="3" operator="IN"/>
  </node>
  <node decision_index="2" expression="C" index="2">
   <path expression="E,F,G" node_index="4" operator="NOT IN"/>
  </node>
  <node decision_index="3" expression="" index="3"/>
  <node decision_index="4" expression="" index="4"/>
 </nodes>
 <decisions>
  <decision id="decision0" index="0"/>
  <decision id="BETWEEN" index="1"/>
  <decision id="NOT BETWEEN" index="2"/>
  <decision id="IN" index="3"/>
  <decision id="NOT IN" index="4"/>
 </decisions>
 <constants/>
</decision_tree>
```

